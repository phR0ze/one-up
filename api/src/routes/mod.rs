/*!
 * Axum route handlers
 */
use axum::{middleware, routing::{get, post}, Router};
use std::sync::Arc;

use crate::{state, security::auth};

// Exports
mod health;
mod login;
mod users;
mod roles;
mod passwords;
mod actions;
mod categories;
mod points;
mod rewards;

/// Configure api routes
pub(crate) fn init(state: Arc::<state::State>) -> Router {

  // TODO: layer in security
  // let sensitive_headers = vec![header::AUTHORIZATION, header::COOKIE].into();

  // Disabling CORS across my routes for now
  // TODO: revisit where to enable CORS
  // let cors = cors::CorsLayer::new()
  //   .allow_methods([Method::GET, Method::POST])
  //   .allow_origin(cors::Any)
  //   .allow_headers([header::CONTENT_TYPE]);

  let health_routes = Router::new()
    .route("/health", get(health::get));

  let login_routes = Router::new()
    .route("/login", post(login::login))
    .route("/protected", get(login::protected)
      .layer(middleware::from_fn(auth::get_auth))
    );

  let users_routes = Router::new()
    .route("/users",
      get(users::get_all).post(users::create))
    .route("/users/{opt}",
      get(users::get_by_id).put(users::update_by_id).delete(users::delete_by_id));

  let passwords_routes = Router::new()
    .route("/passwords",
      get(passwords::get).post(passwords::create))
    .route("/passwords/{opt}",
      get(passwords::get_by_id).delete(passwords::delete_by_id));

  let roles_routes = Router::new()
    .route("/roles",
      get(roles::get).post(roles::create))
    .route("/roles/{opt}",
      get(roles::get_by_id).put(roles::update_by_id).delete(roles::delete_by_id));

  let categories_routes = Router::new()
    .route("/categories",
      get(categories::get).post(categories::create))
    .route("/categories/{opt}",
      get(categories::get_by_id).put(categories::update_by_id).delete(categories::delete_by_id));

  let actions_routes = Router::new()
    .route("/actions",
      get(actions::get).post(actions::create))
    .route("/actions/{opt}",
      get(actions::get_by_id).put(actions::update_by_id).delete(actions::delete_by_id));

  let points_routes = Router::new()
    .route("/points",
      get(points::get).post(points::create))
    .route("/points/{opt}",
      get(points::get_by_id).put(points::update_by_id).delete(points::delete_by_id));

  let rewards_routes = Router::new()
    .route("/rewards",
      get(rewards::get).post(rewards::create))
    .route("/rewards/{opt}",
      get(rewards::get_by_id).put(rewards::update_by_id).delete(rewards::delete_by_id));

    // Merge all routers into the final router
  Router::new()
    .merge(health_routes)
    .merge(login_routes)
    .merge(users_routes)
    .merge(passwords_routes)
    .merge(roles_routes)
    .merge(categories_routes)
    .merge(actions_routes)
    .merge(points_routes)
    .merge(rewards_routes)
    // .layer(cors)
    
    // Add the Fastrace layer for observability
    .layer(fastrace_axum::FastraceLayer)

    // Add the state layer to access application state
    .with_state(state)
}

// -------------------------------------------------------------------------------------------------
// Custom rejection for JSON payloads so that we can return a consistent error response whether it
// was generated by an extractor early on or by application code during the handling of the request.
// -------------------------------------------------------------------------------------------------

// Converts into an `errors::Error` in the extraction rejection path
#[derive(axum::extract::FromRequest)]
#[from_request(via(axum::Json), rejection(crate::errors::Error))]
pub struct Json<T>(T);

// Converts to `IntoResponse` in the positve extraction path
impl<T: serde::Serialize> axum::response::IntoResponse for Json<T> {
    fn into_response(self) -> axum::response::Response {
        let Self(value) = self;
        axum::Json(value).into_response()
    }
}
